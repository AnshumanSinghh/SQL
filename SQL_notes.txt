To create table: CREATE TABLE table_name();
CRETAE TABLE flights(
	id INTEGER PRIMARY KEY AUTOINCREMENT,
	origin TEXT NOT NULL,
	destination TEXT NOT NULL,
	duration INTEGER NOT NULL
       );	

==> inside the table parenthesis we have written teh column names, that we want in our Table.
    id will be autogenerated as it is mentioned as AUTOINCREMENT & it will be also unique and
    NOT NULL bcz it is a PRIMARY KEY.
-- Acutally for each columns, the types for each of the columns and then any constraint we would
   want to place on the columns should be mentioned.

====== CONSTRAINTS ======
. CHECK - The value obeys a certain condition (like we can define a range for movie rating).
. DEFAULT
. NOT NULL - Cant be empty or zero
. PRIMARY KEY - Cant be null and will be UNIQUE too.
. UNIQUE - It makes sure that every value must be unique.

==> Via constraints we begin to ensure that as we add data to the table, taht data is going to
    be valid in some way. That it needs to obey certain constraints. Otherwise ,if we try to add
    add it to the table it's not going to be accepted at all.

To add Data into the Table: INSERT INTO table_name();  [IT will add a new row to the Table]
INSERT INTO flights
	(origin, destination, duration) --> all of the column names for which we are going to provide values.
	VALUES ("New York", "London", 415); --> values corresponding to the column names.

To retrieve the Data out of the Table: SELECT
SELECT * FROM flights; (here * is a wild card which means select all of the possible columns that you can).

Instead of selecting the whole columns we can select only particular columns too.
SELECT origin, destination FROM flights;  --> This will select only origin and destination column.

For Selecting only a particular row: SELECT * FROM table_name WHERE id = 3(any number);
SELECT * FROM flights WHERE id = 3;  --> It will show the data where the column name is id and value is 3, means a particular row only.
Similarly, SELECT * FROM flights WHERE origin = "New York"; (gives Data for all the flights having "New York" as origin).


To organise the Data nicely or to make the table look prettier: 
sqlite> .mode columns
sqlite> .headers yes 

We can add or use Boolean expression:
Like, SELECT * FROM flights WHERE duration > 500;

We can join more than one expression by using AND & OR keyword:
SELECT * FROM flights WHERE duration > 500 AND WHERE destination = "New York";
Similarly,
SELECT * FROM flights WHERE duration > 500 OR WHERE destination = "New York";

To check for sequence of possible values:
SELECT * FROM flights WHERE origin IN ("New York", "New delhi"); 
Returns all the possible rows having origin either "New York" or "New Delhi".

SELECT * FROM flights WHERE origin LIKE "%a%";
It will return all the rows in which origin has a or A in it's name. 
% is a wild card means zero more repeatation of any character mentioned just after that.

===== FUNCTIONS =====
1. AVERAGE
2. COUNT
3. MAX
4. MIN
5. SUM

To UPDATE the exixting Data: 
UPDATE flights
	SET duration = 430
	WHERE origin = "New York"
	AND destination = "London";
To DELETE DATA:
DELETE  FROM flights WHERE destination = "Tokyo";

There is other clause too that we can sue to add additional funtionality:
1. LIMIT -- To put a limit, suppose i want only 5 rows then i will use: SELECT * FROM flights, LIMIT 5;
2. ORDER BY -- we can order the data by our own choice, lets say ORDER BY destination means: all the
	       flights in order by how long they are.
3. GROUP BY -- It allows us to group a whole bunch of rows together.
4. HAVING -- to ensure that it must contains the certain condition.

Joining multiple Tables together: 
SELECT first, origin, destination
	FROM flights JOIN passengers
ON passengers.flight_id = flights.id;
"ON" is used to tell that how it is these two tables are related to one another:-
flight_id column of passengers Table is associated with the id column of the flights Table.

=== DIFFERENT TYPES OF JOIN ===
1. JOIN / INNER JOIN
2. LEFT OUTER JOIN
3. RIGHT OUTER JOIN
4. FULL OUTER JOIN

###### SQL OPTIMIZATION ######
Other stratgies that can be helpful when dealing with SQL tables are optimization we can
make to make queries more efficient.

CRETAE INDEX :-- We can think of an index as kind of the index in the back of a book, for
example, where if we wanted to be able for search for a topic in a text book.
INDEX is an additional structure that can be constructed, and does take time and memory
to be able to construct thid data structure and to maintain it anytime we update the data
inside the Table. But once it exists it make querying on a particular column much more efficient.
We can very quickly look something up in the index and find the corresponding rows that go
along with it.

Command:-- CREATE INDEXV name_index ON table_name;
CREATE INDEX name_index on passengers (last);  -- (last is to create on the last name column of the table)
By doing this, we are pretty frequently going to be looking up passengers by their last name.

======= SQL INJECTION =========
To deal with SQL INJECTION ATTACKS we can use escape characters so that it escapes these unwanted syntaxes or characters.
Like, 
SELECT * FROM users 
WHERE username = "hacker"--" AND password = "";
Since, "--" dash dash is used for comment in SQL so after the username everything will be ignored
and the hacker can have successfully login into our webpages (or better say bypass a password check and log into account).

======= RACE CONDITIONS =======
A race condition is something that might happen anytime we have multiple events that are happening in parallel threads,
That we have one thing happening and another thing happening simultaneously. Suppose two or more people like a post at the
same time. If we'are not carefu; about how we run those particular SQL queries there's a potential for us to get race condition
problems. where we end up trying to query the number of likes that a post has and then another person tries to do the same thing
and there are conflicts when we try and update it, wher the result might not be what we would expect it to be.

How do we solve this problem ?
One strategy is to sort of place a lock on the database.  to say, while I'm working on this database nobody else
can touch this data. Let me finish this transaction, so to speak. Finish working on this particualr transaction and
making all the changes I need to make to the database. And only I'm done I can release the lock and let someone else go
ahead and modify the database as well.
